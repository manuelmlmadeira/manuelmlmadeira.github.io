<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="-mRHvwnHdFYIa-KaKIgZIGLfsdeDLGZ9rZEsWECSiuE"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Heat #3 - The Heat Equation (and a Physics-Informed Neural Network) | Manuel Madeira</title> <meta name="author" content="Manuel Madeira"> <meta name="description" content="Third blogpost of the Heat series. It shows how to solve the Heat equation using a Physics-Informed Neural Network (PINN)."> <meta name="keywords" content="Manuel, Madeira, personal, web, site, page, machine learning, artificial intelligence"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%92%A1&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://manuelmlmadeira.github.io/blog/2022/heat-3-PINN/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Manuel <span class="font-weight-bold">Madeira</span></a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Heat #3 - The Heat Equation (and a Physics-Informed Neural Network)</h1> <p class="post-meta">March 22, 2022</p> <p class="post-tags"> <a href="/blog/2022"> <i class="fas fa-calendar fa-sm"></i> 2022 </a> </p> </header> <article class="post-content"> <p><strong>Authors</strong>: Manuel Madeira, David Carvalho</p> <p><strong>Reviewers</strong>: Fábio Cruz</p> <p><em>This blog post was developed while working at <a href="https://inductiva.ai/" rel="external nofollow noopener" target="_blank">Inductiva Research Labs</a>.</em></p> <hr> <p>As our scientific and technological needs evolve, it is not unrealistic to expect problems depending on solving <em>billions</em> of partial differential equations (PDEs) with hundreds of variables and defined on high-dimensional spaces with hard boundaries constraints.</p> <p>Can Deep Learning lend us a hand in this regard? Let’s find out!</p> <p>Employing a disruptive ethos, in this post we will <em>hopefully</em> convince you that there is a whole lot of potential stemming from <strong>Deep Learning</strong> (DL) methods in tackling this issue.</p> <p>In recent years, huge developments in Machine Learning have been triggered by ever-enhancing computational infrastructure and modeling sophistication.</p> <p>In fields such as Computer Vision or Natural Language Processing, Deep Learning (the sub-field of Machine Learning that handles Neural Networks (NNs)) has evolved as to allow for huge advances in what can be done.</p> <p>In fact, three extremely powerful points assure any researcher that NNs can be leveraged in their field:</p> <ul> <li>the capability NNs have to succeed handling extremely high-dimensional spaces (for which we have motivated bottleneck-level issues due to the <em>curse of dimensionality</em> will almost invariably arise);</li> <li>theoretical guarantees of success, namely due to the <em>Universal Approximation Theorem</em> [1];</li> <li>better still, all the DL software artillery available has dramatically lowered the entry barrier for deploying NNs frameworks. It has never been this easy to set up sophisticated models with a handful of lines of code!</li> </ul> <p>It is no surprise that NNs started invading other territories and <strong>Fundamental Sciences are no exception.</strong></p> <h2 id="deep-learning-for-partial-differential-equations">Deep Learning for… Partial Differential Equations?</h2> <p>The underlying laws behind most natural sciences rely on equations dictating how certain quantities vary in time and space. Naturally, we must wonder:</p> <blockquote> <p>Can we possibly solve such an abstract problem like a Partial Differential Equation (PDE) with the aid of NNs?</p> </blockquote> <p>To answer this question, let’s first formalize a bit. In PDEs, the unknowns are functions which depend on various variables and are defined over some domain. <em>Solving the PDE (or systems thereof)</em> entails finding such functions.</p> <p>For a single real-valued PDE with $n$ spatial variables $r_i$ and a single temporal variable $t$, we are after a function $u: \Omega \in \mathbb{R}^{n+1} \rightarrow \mathbb{R}^d$ which satisfies:</p> \[\mathcal{F} \left[u, \frac{\partial u}{\partial r_i}, \frac{\partial u}{\partial t}, \ldots \right] = 0,\] <p>where $d$ sets thedimensionality of the output. <br> $\mathcal{F}$ is a <em>differential operator</em> — an operator which may depend on those variables but also on the trial solution itself and, most importantly, on its <em>derivatives</em>. In general, these derivative can involve any order term.</p> <p>Our hope is thus to find a NN whose output trial solution can mimic the actual PDE solution.</p> <h2 id="deep-advantages">Deep Advantages</h2> <p><em>Guess what</em>? As parametric function approximators, NNs are particularly well tailored for this problem.</p> <p>If you recall what we discussed, many limiting issues are found when numerically solving a PDE via a classical method by <strong>discretizing</strong> the domain — usually performed with Finite Difference or Finite Element Methods. Ideally, we would like to circumvent these problems.</p> <p>As we will soon see, PINNs (Physics-Informed Neural Networks) address most of the previously mentioned limitations of the classical methods:</p> <ul> <li>they are <strong>mesh-free</strong>, making the interpolation for non-mesh points no longer a concern. Once trained, PINNs can be evaluated at any point of the domain of interest. The way the training is performed can also be adjusted so that the function-valued solution we seek can be found in very efficient ways;</li> <li>there is no such thing as <strong>error buildup</strong> or <strong>instability</strong> coming from the iterative nature and discretization imposed by the classical methods.</li> </ul> <p>For now, it’s clear — we should express a solution of the PDE as a NN.</p> <p>Buckle yourself up and let the fun begin!</p> <h2 id="physics-informed-neural-networks-pinns">Physics-Informed Neural Networks (PINNs)</h2> <p>We will showcase you one of the hottest approaches to tackle PDEs from a DL perspective — Physics-Informed Neural Networks (PINNs) [2,3].</p> <p>In what way does this architecture differ from more conventional NN models? Well, firstly we:</p> <ul> <li>try to approximate the function solution to the PDE through a NN that fits some data points that are provided. Typically, these are points set by boundary and initial conditions but they can also be in the interior of the domain;</li> <li>constrain the space of functions from which the NN can learn by penalizing solutions whose partial derivatives do not satisfy the desired PDE.</li> </ul> <p>The first point is commonplace in DL approaches. This simply entails a ‘supervised’ minimization procedure between the output and the <em>ground truth</em> set by the conditions. This <em>flavor</em> of architecture is normally termed <strong>vanilla</strong>.</p> <p>The whole novelty and potential of PINNs stem from the second term, which is the one that fundamentally deviates from the vanilla DL by regularizing NN guesses.</p> <p>It’s this aspect that coins these NNs as <em>Physics-informed</em>: from all the NNs that we could learn, we are imposing an inductive bias towards those that verify the <em>Physics</em> of the system at hand (<em>i.e.</em> what the conditions expressed in the PDE enforce).</p> <p>The idea of <em>Physics</em> here is a bit misleading. PINNs do <strong>not</strong> have to pertain to physical systems. By Physics, it is assumed that some strong principle or law must be held across the system. Curiously enough, these tend to be expressed precisely with PDEs!</p> <h2 id="training-the-pinn">Training the PINN</h2> <p>But how can we obtain a NN that we are confident has mimicked the <em>actual</em> solution of the PDE taking into consideration the two aforementioned notions?</p> <p>Needless to say, there are <em>many</em> answers, depending on the problem at hand. For instance, we could</p> <ul> <li>try to construct (activation) functions that necessarily respect the differential equation;</li> <li>if, say, the PDE were linear, use linear combinations of solutions so to respect the PDE;</li> <li>work in the spectral (frequency) domain — where the derivatives could be tight by some relation — and consequently an inverse fast Fourier transform could be used to map the solution to the direct domain.</li> </ul> <h3 id="a-clever-loss-function">A Clever Loss Function</h3> <p>The answer that requires minimal change though is to tweak the way the loss function is computed. This <em>objective</em> function $\mathcal{L}$ is parametrized by tunable parameters $\mathbf{\theta} = (\theta_1, \theta_2, …)$ and dictated by the model. In order to <strong>learn</strong> the solution, this loss must be <strong>minimized</strong>.</p> <p>We want to make the loss as small as possible. Once we’re in that regime, we can be fairly sure our trial output is <em>somehow</em> close to the <em>true</em> solution and we can say our model has <strong>learnt</strong> how to solve the PDE.</p> <p>Tracking the behavior of $\mathcal{L}$ allows the NN to adjust its internal parameters towards the values that lead to a smaller loss and thus to the best approximation of the PDE output by the NN.</p> <p>Considering this motivation — admittedly more mathematical — we can now formulate the impact of each term on the overall loss through an individual term:</p> <ul> <li> <p><strong>Output values loss</strong> $\mathcal{L}<em>\mathrm{data}$ — any loss that penalizes a NN that does not verify the value function at the several prescribed points. For instance, we can consider a Mean Squared Error function between the values output by the NN and the target ones (which we know _a priori</em>):</p> \[\mathcal{L}_\mathrm{data} = \frac{1}{N} \sum_{i=1}^N \|\hat{u}(t^i, r^i_1, \ldots, r^i_n) - u^i\|^2,\] <p>where $\hat{u}(\ldots)$ is the NN estimate and $u^i$ is the <em>ground truth</em> value of $u$ at the point $(t^i, r^i_1, \ldots, r^i_n)$.</p> <p>Typically, the $N$ points used to compute $\mathcal{L}_\mathrm{data}$ are drawn from the initial and the boundary conditions, but this is <em>not</em> strict — those could be any points!</p> </li> <li> <p><strong>PDE “Regularization”</strong> $\mathcal{L}_\mathrm{PDE}$ — a term which penalizes models that do not satisfy the PDE. To achieve this, we can use a little trick. Since we wrote our PDE in the form $\mathcal{F}[u, \ldots]=0$, we want the left-hand side to be as close to $0$ as possible. We can then simply make sure our mimicking function $\hat{u}$ yields the lowest loss:</p> \[\mathcal{L}_\mathrm{PDE} = \frac{1}{N} \sum_{i=1}^N \|\mathcal{F}[\hat{u}(t^i, \mathbf{r}^i)]\|^2.\] <p>Easier said than done. This is a colossal task for each parameter instantiation of our NN (hundreds of billions of parameters may have to be recalibrated!)</p> <p>However, we can benefit from the auto-differentiation artillery that has been developed for NNs: the available packages allow for a straightforward and efficient way of obtaining the partial derivatives with respect to the many model inputs.</p> <p>In contrast to the first point, this loss term can be applied to <em>any</em> point, given that we do not require prescribed target values.</p> </li> </ul> <p>We are now in conditions to obtain a total loss term by summing both loss terms:</p> \[\mathcal{L}_\mathrm{PINN} = \mathcal{L}_\mathrm{data} + \mathcal{L}_\mathrm{PDE}.\] <p>Even though both terms were weighted evenly, this is not a requirement. Actually, it is quite common to find this loss defined as a convex combination of those two terms, where the weighting coefficient is an extra hyperparameter requiring appropriate fine-tuning.</p> <p>But putting these and other technicalities aside, this is pretty much what you need to know about PINNs to follow the rest of this post!</p> <div style="text-align: center;"> <img style="width:60%;" src="../../../assets/img/blogposts/heat3/PINN_sketch.png"> </div> <p><strong>Fig. 1</strong>: The PINN we used to solve the 2D Heat Equation consists of two parts: firstly, by updating the NN’s weights $\mathbf{W}$ and biases $\mathbf{b}$ we can minimize the residual difference between the model and the prescribed values at some selected points; then the NN output is also optimized so that $|\mathcal{F}[u, \ldots] |$ gets as close to 0 as possible. Credits: David Carvalho / Inductiva</p> <h3 id="idrlnet-a-pinns-library">IDRLnet: a PINNs library</h3> <p>To set a DL algorithm, we use <a href="https://idrlnet.readthedocs.io/en/latest/index.html" rel="external nofollow noopener" target="_blank">IDRLnet</a>, a PINNs library built on Pytorch [4]. To the best of our knowledge, it is one of the most versatile open-source PINNs library.</p> <p>The IDRLnet library has an architecture based on three different types of nodes:</p> <ol> <li> <strong><code class="language-plaintext highlighter-rouge">DataNodes</code></strong> - these are essentially domains that are obtained from Geometric Objects (also provided by the library), from where it is possible to sample the points used to train the PINN;</li> <li> <strong><code class="language-plaintext highlighter-rouge">NetNodes</code></strong> - these are abstracted from neural networks, <em>i.e.</em> the architecture, training hyperparameters, and everything else related to the NN used are defined in this node;</li> <li> <strong><code class="language-plaintext highlighter-rouge">PDENodes</code></strong> - these contain all the information related to the PDE we wish to solve. Contrarily to NetNodes, PDENodes do not have trainable parameters.</li> </ol> <p>Fine — we are ready to try it out on our new favorite PDE: the 2D Heat Equation!</p> <h2 id="hot-nn-coming-through">Hot NN Coming Through!</h2> <p>To keep things simple, let us start with the exact same situation as the one presented for FDM:</p> <div style="text-align: center;"> <img style="width:40%;" src="../../../assets/img/blogposts/heat3/BIC.png"> </div> <p><strong>Fig. 2</strong>: The boundary and initial conditions used throughout the Heat series. Energy is pumped from the top edge onto an initially completely cold 2D plate. Credits: David Carvalho / Inductiva.</p> <p>A very simple domain was chosen — a regular 2D square plate. We must then consider points of the form $(t, \mathbf{r}) = (t, x, y)$. The temperature $u(t, \mathbf{r})$ must satisfy <em>the 2D Heat Equation</em>:</p> \[\left[ \frac{\partial}{\partial t} - D \left( \frac{\partial^2}{\partial x ^2} + \frac{\partial^2}{\partial y ^2} \right) \right]u(t,x,y)= 0\] <p>Recall that the hot edge was kept at the <em>maximal</em> temperature ($1\;^\mathrm{o}C$), while the remaining boundaries at the <em>minimal</em> temperature ($-1\;^\mathrm{o}C$). Initially, at $t=0$, all points were kept at the minimal temperature too.</p> <p>This prescription allows us to compute the loss term $\mathcal{L}<em>{\mathrm{data}}$. As for the regularization, the loss term $\mathcal{L}</em>{\mathrm{PDE}}$ is:</p> \[\mathcal{L}_\mathrm{PDE} = \frac{1}{N} \sum_{i=1}^N \left\|\left[ \frac{\partial}{\partial t} - D \left( \frac{\partial^2}{\partial x ^2} + \frac{\partial^2}{\partial y ^2} \right) \right]\hat{u}(t^i,x^i,y^i) \right\|^2= 0.\] <h2 id="time-to-heat-start">Time to Heat [Start]</h2> <p>You can find our code <a href="https://github.com/inductiva/blog_code_snippets" rel="external nofollow noopener" target="_blank">here</a> and run your very first PINN! Run this experiment through the following instruction in the command line:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python heat_idrlnet.py --max_iter=10000 --output_num_x=500 --output_num_y=500 --colorbar_limits=-1.5,1.5
</code></pre></div></div> <p>The flags used trigger the following instructions:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">max_iter</code> defines the total number of training epochs;</li> <li> <code class="language-plaintext highlighter-rouge">output_num_x</code> and <code class="language-plaintext highlighter-rouge">output_num_y</code> define the discretization along the x-axis and y-axis, respectively, of the grid in which we infer results;</li> <li> <code class="language-plaintext highlighter-rouge">colorbar_limits</code> defines the range of the colorbar used.</li> </ul> <p>For illustrative purposes, we set the diffusivity constant to $D=0.1$ throughout the entire post.</p> <p><strong>Disclaimer:</strong> our code is able to accommodate some extra complexity that is not needed in this post. For now though, we will not dive in detail but let the magic happen in the next section 😎.</p> <h2 id="classical-vs-nn--the-fight-begins">Classical vs NN — the fight begins</h2> <p>To see how well our NN-based framework handles the task, we can compare the NN output to the one generated from the classical Finite-Differences algorithm:</p> <p>Let’s plot the output obtained with the FDM (a classical algorithm) [top] and a PINN we trained [middle], as well as the error $\text{Error} = |u_{\rm FDM} - u_{\rm PINN}|$ [bottom]. This error plot can be easily computed by running the provided <code class="language-plaintext highlighter-rouge">heat_error.py</code> python script.</p> <div style="text-align: center;"> <video class="mb-0" style="width:80%;" loop="" muted="" autoplay="" preload="auto"> <source src="../../../assets/img/blogposts/heat3/fdm.mp4" type="video/mp4"></source> </video> <video class="mb-0" style="width:80%;" loop="" muted="" autoplay="" preload="auto"> <source src="../../../assets/img/blogposts/heat3/idrlnet_10000epochs.mp4" type="video/mp4"></source> </video> <video class="mb-0" style="width:80%;" loop="" muted="" autoplay="" preload="auto"> <source src="../../../assets/img/blogposts/heat3/error_10000epochs.mp4" type="video/mp4"></source> </video> </div> <p><strong>Fig. 3</strong>: Comparison of the results obtained via a classical algorithm (a FDM)[top], a DL algorithm (the PINN computed with IDRLnet)[middle] and the absolute value of their difference [bottom]. They seem very similar! Indeed, an inspection of the error shows global convergence. Credits: Manuel Madeira / Inductiva</p> <p>Wow — this looks rather good!</p> <p>The NN output approximates quite closely the results obtained with FDM. There are some deviations mainly in the initial instants and then in the upper corners. Actually, these are the regions where sharper transitions of the solution function are found, and it is thus natural that our PINN has more difficulty to fit correctly there.</p> <p>This certainly seems hopeful — but an inquisitive mind like yours must be wondering about <em>why</em> this PINN worked.</p> <h2 id="how-long-should-we-train">How long should we train?</h2> <p>In order to train the PINN, a rather large number of epochs ($N_{\rm epochs}=10000$) was used for training.</p> <p>This can make us think: just like the classical algorithm had to be tuned so no nonsensical estimates were output, there must be some suitable tuning to assure us the algorithm can indeed approximate the solution.</p> <div style="text-align: center;"> <video class="mb-0" style="width:80%;" loop="" muted="" autoplay="" preload="auto"> <source src="../../../assets/img/blogposts/heat3/error_100epochs.mp4" type="video/mp4"></source> </video> <video class="mb-0" style="width:80%;" loop="" muted="" autoplay="" preload="auto"> <source src="../../../assets/img/blogposts/heat3/error_1000epochs.mp4" type="video/mp4"></source> </video> <video class="mb-0" style="width:80%;" loop="" muted="" autoplay="" preload="auto"> <source src="../../../assets/img/blogposts/heat3/error_10000epochs.mp4" type="video/mp4"></source> </video> </div> <p><strong>Fig. 4</strong>: Difference between the PINN output after training with different number of epochs and its respective classical output (serving as a benchmark). We can see a substantial error for few epochs ($N_{\rm epochs} = 100$) [top]. If we ramp up 10-fold ($N_{\rm epochs} = 1000$), the error is essentially gone [middle] and even further suppressed for $N_{\rm epochs} = 10000$ [bottom]. For this regime, both the classical and DL algorithms provide essentially the same estimate. Credits: Manuel Madeira / Inductiva.</p> <p>The results are just as we expected: the higher $N_{\rm epochs}$, the better the NN learns. In this particular case, it seems that by around $N_{\rm epochs} \approx 1000$ it already leads to appropriate learning. In general, tuning this parameter can be costly (moreso if performed in a brute force fashion).</p> <p>Specific knowledge of the PDE or domain in question may make our lives easier!…</p> <h2 id="customized-training">Customized training</h2> <p>The versatility of the PINNs in focusing on different regions differently begs a question of the utmost relevance:</p> <blockquote> <p>Are we favoring or penalizing regions that require a different level of refinement?</p> </blockquote> <p>Fortunately, via <em>TensorBoard</em>, it is possible to track various loss terms throughout the training procedure by using the command</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tensorboard --logdir [insert path to "network_dir"]
</code></pre></div></div> <p>With it, we can then see the effect of extending the training procedure. For this, we set different <strong>numbers of epochs</strong> and see how the output is impacted by this choice.</p> <div style="text-align: center;"> <img style="width:95%;" src="../../../assets/img/blogposts/heat3/learning_across_epochs.png"> </div> <p><strong>Fig. 5</strong>: Learning curves (in logarithmic scale) for different sub-domains. We can see that, even though all terms have different behavior, they eventually converge to exceedingly small values. Credits: Manuel Madeira / Inductiva.</p> <p>You can see how the loss for various subdomains (the captions should be clear to follow) changes as training takes place.</p> <p>The training of PINNs (or generally with NNs), is <strong>not</strong> a completely trivial task. In fact, from the learning curves above, it is clear that if we stopped our training too early on, our results would be necessarily <strong>worse</strong>.</p> <h2 id="the-ghost-of-overfitting">The ghost of <em>overfitting</em> </h2> <p>We typically find overfitting whenever we train our model excessively with a training dataset — ultimately providing a strict fitting across the given data points, or when training using a closed dataset (by <em>not</em> using randomly-generated data).</p> <p>This leads to a huge drawback: <strong>the model loses its generalization capability</strong>.</p> <p>In other words, when we present the model to new <strong>unseen</strong> data still from the same distribution that generated the training dataset, the model will have <em>weak</em> predicting power for those points and thus a <strong>much higher</strong> loss rate.</p> <p>A validation set of data points is typically kept in parallel to the NN training procedure to ensure, through periodic checks, that we do not enter such an overfitting regime.</p> <p>In this case, we do not have to worry about the possibility of overfitting for two main reasons:</p> <ul> <li>firstly, we are sampling a different set of data points in each epoch, <em>i.e.</em>, our training set is changing from epoch to epoch</li> <li>secondly, we are considering a regularization term in our loss (recall $\mathcal{L}_\mathrm{PDE}$).</li> </ul> <p>Furthermore, we see that points coming from the boundary conditions are the most troublesome ones — due to their higher loss. To contrast this, FDM implementations have those points directly <em>hard-coded</em> onto the final solution.</p> <h2 id="learning-rate">Learning Rate</h2> <p>Another typical issue impacting the performance of PINNs (and NNs in general) is the choice of the learning rate $\alpha$.</p> <p>This is a <em>hyperparameter</em> — a variable which pertains to the structure of the model itself. The update of the NNs parameters is performed by applying optimization algorithms, thus known as <em>optimizers</em>.</p> <p>The way in which the learning rate is exploited in these optimizers varies. However, we can intuitively think about it as the magnitude of the step given in the parameters space in each iteration.</p> <p>Striking a balance between <em>speed</em> and <em>accuracy</em> is not only a vital part of setting the model but also a delicate task on its own.</p> <p>A <strong>larger</strong> learning rate allows us to have larger updates in the parameters and thus <strong>faster</strong> progress but at the same time it may lead to <strong>large instabilities</strong> in the convergence process. In extreme instances, we may never be in conditions to access the optimal regions.</p> <p>To see this, let us see the effect of using larger and smaller learning rates $\alpha$ than the one chosen in the previous experiment.</p> <div style="text-align: center;"> <img style="width:95%;" src="../../../assets/img/blogposts/heat3/big_lr.png"> <img style="width:95%;" src="../../../assets/img/blogposts/heat3/small_lr.png"> </div> <p><strong>Fig. 6</strong>: Learning curves (in logarithmic scale) for two different learning rates. Note that a very large rate $\alpha = 0.1$ leads to curves that never get smaller and so the NN is bound to fail [top]. Using a smaller rate ($\alpha=0.0001$) [bottom], although takes more time to run, indeed leads to increasingly smaller losses. Credits: Manuel Madeira / Inductiva.</p> <p>On the one hand, for $\alpha = 0.1$, the model runs rather quickly but the learning curve stagnates quickly since further progress will not get us closer to the optimal minima of the loss function – we simply keep meandering in parameter space!</p> <p>Contrary to this regime, a small rate $\alpha=0.0001$ may take more time but allows the model to eventually have ever-smaller losses.</p> <p>Balancing performance, accuracy and computation resources surely is a sophisticated feat!</p> <h2 id="there-is-art-in-dl">There is art in DL</h2> <p>The lesson we learnt here is that indeed NNs can be adequately trained to yield estimates of PDE solutions <strong>without explicit computation of the PDE</strong>.</p> <p>For that though, we must be crafty — choices like the learning rate and the number of epochs <strong>directly impact</strong> the performance of the PINN.</p> <p>The fine-tuning of hyperparameters is not something set on stone and requires subtlety and exploration to be successful. The technical aspects and their formulation are still open topics and intensively studied in the DL+ML communities.</p> <p>Just as with FDMs we had to fine-tune the discretization parameters in order to ensure the stability of the method, the same must be considered for PINNs — they are not a panacea! Even though it offers an edge in streamlining the computation of the estimate, extra care is still needed!</p> <p>NN architectures come in many flavors and recipes and may be improved in many intuitive ways. As a general question, we can wonder:</p> <blockquote> <p>Should we take some inspiration from the classical methods and explore a direction where the boundary (and initial) conditions are hard-constrained in the learning problem (<em>e.g.</em> verified by construction)?</p> </blockquote> <p>This is one of the questions that we are tackling at Inductiva — and we will show you more as progress is made 😛!</p> <h2 id="next-episode">Next episode</h2> <p>In the next (and final!) section of our tutorial, we will precisely unveil some of the aspects that can make our problem harder to solve but also <strong>more realistic</strong>.</p> <p>In particular, we will show you how to extend this vanilla version of PINNs to be able to:</p> <ul> <li>deal with complex geometries (rather than a simple square plate);</li> <li>solve a PDE to more than one instance of the boundary conditions without having to retrain the whole model again.</li> </ul> <p>Neural Networks sure sound exciting, right? Stay tuned 🌶️!</p> <h2 id="references">References</h2> <p><a href="https://en.wikipedia.org/wiki/Universal_approximation_theorem" rel="external nofollow noopener" target="_blank">[1]</a> A bit more about the mathematical foundation for the suitabillity of NNs to model challenging maps from input to output. <br> <a href="https://arxiv.org/abs/1711.10561" rel="external nofollow noopener" target="_blank">[2]</a> Defining papers outlining the architecture and ideas of PINNs in the Literature. <br> <a href="https://www.sciencedirect.com/science/article/pii/S0021999118307125" rel="external nofollow noopener" target="_blank">[3]</a> Yet another influential paper on PINNs. <br> <a href="https://idrlnet.readthedocs.io/en/latest/" rel="external nofollow noopener" target="_blank">[4]</a> Check out the documentation of the IDRLnet library here.</p> </article> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container"> © Copyright 2025 Manuel Madeira. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["\\[","\\]"]],tags:"ams"},svg:{fontCache:"global"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-6BNW5R0VXG"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-6BNW5R0VXG");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>